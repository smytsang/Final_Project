<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Game</title>
  </head>
  <body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
      const GRAVITY = 2;
      const FRICTION = 0.8;

      let playerX = 0;
      let playerY = 0;
      let playerSpeedX = 0;
      let playerSpeedY = 0;
      let playerOnGround = false;

      const PLAYER_RADIUS = 10;
      const JUMP_HEIGHT = 15;
      const PLAYER_SPEED = 5;

      const LEFT_ARROW = 37;
      const UP_ARROW = 38;
      const RIGHT_ARROW = 39;
      let keyLeft = false;
      let keyRight = false;

      window.onload = function () {
        canvas = document.getElementById('gameCanvas');
        canvasContext = canvas.getContext('2d');

        let framesPerSecond = 30;
        setInterval(updateAll, 1000/framesPerSecond);

        setupInput();
        playerReset();
      }

      function setupInput () {
        document.addEventListener('keydown', keyPressed);
        document.addEventListener('keyup', keyReleased);
      }

      function playerReset() {
        playerX = 75;
        playerY = 475;
      }

      function setKeyTo (key, setTo) {
        if (key == LEFT_ARROW) {
          keyLeft = setTo;
        }

        if (key == RIGHT_ARROW) {
          keyRight = setTo;
        }

        if (key == UP_ARROW) {
          if(playerOnGround) {
            playerSpeedY = -JUMP_HEIGHT;
          }
        }
      }

      function keyPressed (event) {
        // event.preventDefault();
        setKeyTo(event.keyCode, true);
      }

      function keyReleased (event) {
        setKeyTo(event.keyCode, false);
      }

      function updateAll() {
        movePlayer();
        drawAll();
      }

      function movePlayer() {
        // If player is not on ground, go down until it hits tile
        if(!playerOnGround) {
          playerSpeedY += GRAVITY;
          if(playerSpeedY > JUMP_HEIGHT) {
            playerSpeedY = JUMP_HEIGHT;
          }
        }

        // If no keys held, player eventually slows down
        if(playerOnGround) {
          playerSpeedX *= FRICTION;
        }

        if(keyLeft) {
          playerSpeedX = -PLAYER_SPEED;
        }

        if(keyRight) {
          playerSpeedX = PLAYER_SPEED;
        }

        // Checks if player is on top of a tile
        if (playerSpeedY > 0 && isTileAtPixel(playerX, playerY+ 2 * PLAYER_RADIUS)) {
          // debugger;
          playerY = (1+Math.floor(playerY / TILE_H)) * TILE_H - PLAYER_RADIUS;
          playerSpeedY = 0;
          playerOnGround = true;
        } else if(!isTileAtPixel(playerX, playerY+PLAYER_RADIUS+2)) {
          playerOnGround = false;
        }

        // Checks if player hits a tile from below
        if (playerSpeedY < 0 && isTileAtPixel(playerX, playerY-PLAYER_RADIUS)) {
          playerY = (Math.floor(playerY / TILE_H)) * TILE_H + PLAYER_RADIUS;
          playerSpeedY = 0;
        }

        // Checks if player hits on right side
        if (playerSpeedX > 0 && isTileAtPixel(playerX+PLAYER_RADIUS, playerY)) {
          playerX = (1+Math.floor(playerX / TILE_W)) * TILE_W - PLAYER_RADIUS;
          playerSpeedX = 0;
        } else if (playerSpeedX > 0 && playerX+PLAYER_RADIUS >= canvas.width) {
          playerSpeedX = 0;
        }

        // Checks if player hits on left side
        if (playerSpeedX < 0 && isTileAtPixel(playerX-(PLAYER_RADIUS+1), playerY)) {
          playerX = (Math.floor(playerX / TILE_W)) * TILE_W + PLAYER_RADIUS;
          playerSpeedX = 0;
        } else if (playerSpeedX < 0 && playerX-PLAYER_RADIUS <= 0) {
          playerSpeedX = 0;
        }

        // If player falls off bottom of screen
        if(playerY-PLAYER_RADIUS > canvas.height) {
          playerReset();
        }

        playerX += playerSpeedX;
        playerY += playerSpeedY;
      }


      const TILE_W = 40;
      const TILE_H = 40;
      const TILE_GAP = 1;
      const TILE_COLS = 20;
      const TILE_ROWS = 15;

      let tileGrid = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ];

      // Adds an index to all values in the grid
      function tileGridIndex(tileCol, tileRow) {
        return (tileCol + TILE_COLS*tileRow);
      }

      function isTileHere(tileCol, tileRow) {
        let tileIndex = tileGridIndex(tileCol, tileRow);
        // returns true if there is a tile of any kind
        return (tileGrid[tileIndex] != 0);
      }

      function isTileAtPixel(pixelX, pixelY) {
        let tileCol = Math.floor(pixelX / TILE_W);
        let tileRow = Math.floor(pixelY / TILE_H);

        if(tileCol < 0 || tileCol >= TILE_COLS || tileRow < 0 || tileRow >= TILE_ROWS) {
          return false;
        }

        let tileIndex = tileGridIndex(tileCol, tileRow);
        return (tileGrid[tileIndex] == 1);
      }

      function drawAll() {
        colorRect(0, 0, canvas.width, canvas.height, 'black');

        drawTiles()
        colorCircle(playerX, playerY, 10, 'white');
      }

      function drawTiles() {
        for (let col = 0; col < TILE_COLS; col++) {
          for (let row = 0; row < TILE_ROWS; row++) {
            if (isTileHere(col, row)) {
              let tileLeftEdge = col * TILE_W;
              let tileTopEdge = row * TILE_H;

              let tileIndex = tileGridIndex(col, row)
              if (tileGrid[tileIndex] == 1) {
                colorRect(tileLeftEdge, tileTopEdge, TILE_W-TILE_GAP, TILE_H-TILE_GAP, 'brown')
              } else if (tileGrid[tileIndex] == 2) {
                colorRect(tileLeftEdge, tileTopEdge, TILE_W, TILE_H-TILE_GAP, 'blue')
              }
            }
          }
        }
      }

      function colorRect(topLeftX, topLeftY, boxWidth, boxHeight, fillColor) {
        canvasContext.fillStyle = fillColor;
        canvasContext.fillRect(topLeftX, topLeftY, boxWidth, boxHeight);
      }

      function colorCircle(centerX, centerY, radius, fillColor) {
        canvasContext.fillStyle = fillColor;
        canvasContext.beginPath();
        canvasContext.arc(centerX, centerY, radius, 0, Math.PI*2, true);
        canvasContext.fill();
      }

      function colorText(showWords, textX, textY, fillColor) {
        canvasContext.fillStyle = fillColor;
        canvasContext.fillText(showWords, textX, textY);
      }
    </script>
  </body>
</html>
